// Stats Collector
//
// Collects heap size after a GC compaction, guessing whether it's a leak
//
// Authors: Nik Kyriakides
// @nicholaswmin

import v8 from 'node:v8'
import vm from 'node:vm'
import { setTimeout as sleep } from 'node:timers/promises'
import { PerformanceObserver } from 'node:perf_hooks'
import singleLineLog from 'single-line-log'

import { suspendIO, restoreIO }  from './process-io.js'
import Plot from './plot/index.js'

v8.setFlagsFromString('--expose-gc')
global.gc = vm.runInNewContext('gc')

class Memstat {
  constructor({ watch = false, window = {}, ctx = null, updateMs = 100 } = {}) {
    this.watch = watch
    this.window = window
    this.ctx = ctx

    this.initial = v8.getHeapStatistics().used_heap_size
    this.snapshots = [this.initial]
    this.current = null

    this.plot = new Plot({
      initial: this.initial,
      watch: this.watch,
      window: this.window
    })

    if (this.watch) {
      this.observer = new PerformanceObserver(() => this.update().redrawPlot())
      this.observer.observe({ entryTypes: ['gc'] })
      suspendIO()
    }
    this.update()
  }

  // public
  async sample(cb) {
    this.update()

    const res = await cb()

    this.update()

    return res
  }

  // public
  end(ctx) {
    if (this.plot)
      this.update().plot.end()

    global.gc()

    if (ctx?.test)
      this._schedulePlotDraw(ctx.test)

    return new Promise(resolve =>
      process.nextTick(() => resolve(this.getReport())))
  }

  _schedulePlotDraw(test) {
    setTimeout(() => {
      if (!['failed'].includes(test.state))
        return

      console.log(this.plot.generate({
        ...test,
        ...this.getStats()
      }))
    })
  }

  redrawPlot() {
    singleLineLog.stdout(this.plot.generate(this.getStats()))
  }

  // private
  update() {
    this.current = v8.getHeapStatistics().used_heap_size
    this.snapshots.push(this.current)
    this.percentageIncrease = this.percDiffNum(this.initial, this.current)

    this.plot.update(this.getStats())

    return this
  }

  exitWatchMode() {
    this.observer.disconnect()
    clearInterval(this.redrawCycle)
    restoreIO()
  }

  // private
  // creates stats for internal-use, i.e:
  // plot drawing
  getStats() {
    return {
      initial: this.initial,
      snapshots: [ ...this.snapshots ],
      current: this.current,
      percentageIncrease: this.percentageIncrease
    }
  }

  // private
  // public report is generated by this but users
  // should get it via calling `this.end()` in userland
  getReport() {
    return {
      ...this.getStats(),
      plot: this.plot.generate()
    }
  }

  percDiffNum(a, b) {
    let percent

    if (b !== 0) {
      if (a !== 0) {
        percent = (b - a) / a * 100
      } else {
        percent = b * 100
      }
    } else {
      percent = - a * 100
    }

    return Math.floor(percent)
  }
}

export default opts => new Memstat({
  watch: opts?.watch || false,
  window: {
    columns: process.stdout.columns - 25,
    rows: process.stdout.rows - 20
  },
  ...opts
})
